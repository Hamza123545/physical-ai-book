if(void 0===__webpack_require__)var __webpack_require__={};(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2484],{6421:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"chapter-05/lesson-03-trajectory-generation","title":"Lesson 5.3: Trajectory Generation","description":"Generate smooth, time-parameterized trajectories for robot motion","source":"@site/docs/chapter-05/lesson-03-trajectory-generation.md","sourceDirName":"chapter-05","slug":"/chapter-05/lesson-03-trajectory-generation","permalink":"/physical-ai-book/docs/chapter-05/lesson-03-trajectory-generation","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"trajectory","permalink":"/physical-ai-book/docs/tags/trajectory"},{"inline":true,"label":"polynomial","permalink":"/physical-ai-book/docs/tags/polynomial"},{"inline":true,"label":"interpolation","permalink":"/physical-ai-book/docs/tags/interpolation"},{"inline":true,"label":"time-optimal","permalink":"/physical-ai-book/docs/tags/time-optimal"}],"version":"current","frontMatter":{"title":"Lesson 5.3: Trajectory Generation","description":"Generate smooth, time-parameterized trajectories for robot motion","chapter":5,"lesson":3,"estimated_time":60,"cefr_level":"B2","blooms_level":"Apply","digcomp_level":6,"generated_by":"claude-sonnet-4-5-20250929","source_spec":"specs/002-physical-ai-textbook/spec.md","created":"2025-11-29","last_modified":"2025-11-29","git_author":"claude","workflow":"/sp.implement","version":"1.0","prerequisites":["chapter-05/lesson-01-path-planning","chapter-02"],"has_interactive_python":true,"interactive_python_count":4,"has_try_with_ai":true,"try_with_ai_count":2,"tags":["trajectory","polynomial","interpolation","time-optimal"]},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 5.2: Sampling-Based Planning","permalink":"/physical-ai-book/docs/chapter-05/lesson-02-sampling-planning"},"next":{"title":"Lesson 5.4: Feedback Control","permalink":"/physical-ai-book/docs/chapter-05/lesson-04-feedback-control"}}');var r=i(4848),o=i(8453);const s={title:"Lesson 5.3: Trajectory Generation",description:"Generate smooth, time-parameterized trajectories for robot motion",chapter:5,lesson:3,estimated_time:60,cefr_level:"B2",blooms_level:"Apply",digcomp_level:6,generated_by:"claude-sonnet-4-5-20250929",source_spec:"specs/002-physical-ai-textbook/spec.md",created:"2025-11-29",last_modified:"2025-11-29",git_author:"claude",workflow:"/sp.implement",version:"1.0",prerequisites:["chapter-05/lesson-01-path-planning","chapter-02"],has_interactive_python:!0,interactive_python_count:4,has_try_with_ai:!0,try_with_ai_count:2,tags:["trajectory","polynomial","interpolation","time-optimal"]},a="Lesson 5.3: Trajectory Generation",c={},l=[{value:"\ud83c\udfaf Learning Objectives",id:"-learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. Path vs Trajectory",id:"1-path-vs-trajectory",level:2},{value:"2. Polynomial Trajectories",id:"2-polynomial-trajectories",level:2},{value:"Cubic Polynomial (3rd degree)",id:"cubic-polynomial-3rd-degree",level:3},{value:"Quintic Polynomial (5th degree)",id:"quintic-polynomial-5th-degree",level:3},{value:"3. Minimum-Jerk Trajectories",id:"3-minimum-jerk-trajectories",level:2},{value:"4. Time-Optimal Trajectories",id:"4-time-optimal-trajectories",level:2},{value:"5. Exercises",id:"5-exercises",level:2},{value:"Exercise 5.3.1: Cubic Polynomial Trajectory",id:"exercise-531-cubic-polynomial-trajectory",level:3},{value:"Exercise 5.3.2: Velocity Profile",id:"exercise-532-velocity-profile",level:3},{value:"Exercise 5.3.3: Quintic Trajectory",id:"exercise-533-quintic-trajectory",level:3},{value:"Exercise 5.3.4: Multi-Waypoint Trajectory",id:"exercise-534-multi-waypoint-trajectory",level:3},{value:"6. Try With AI",id:"6-try-with-ai",level:2},{value:"TryWithAI 5.3.1: Trajectory Smoothness Analysis",id:"trywithai-531-trajectory-smoothness-analysis",level:3},{value:"TryWithAI 5.3.2: Time-Optimal Trajectory Design",id:"trywithai-532-time-optimal-trajectory-design",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components},{InteractivePython:i,LearningObjectives:n,TryWithAI:s}=t;return i||m("InteractivePython",!0),n||m("LearningObjectives",!0),s||m("TryWithAI",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"lesson-53-trajectory-generation",children:"Lesson 5.3: Trajectory Generation"})}),"\n",(0,r.jsx)(t.h2,{id:"-learning-objectives",children:"\ud83c\udfaf Learning Objectives"}),"\n",(0,r.jsx)(n,{cefr_level:"B2",objectives:[{text:"Distinguish between path (geometric) and trajectory (time-parameterized)",blooms_level:"Understand",assessment_method:"Quiz questions"},{text:"Generate polynomial trajectories with position, velocity, acceleration constraints",blooms_level:"Apply",assessment_method:"Interactive Python exercises"},{text:"Design minimum-jerk trajectories for smooth robot motion",blooms_level:"Apply",assessment_method:"Interactive Python exercises"}]}),"\n",(0,r.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Path planning"})," gives waypoints: [(0,0), (1,2), (3,3)].\n",(0,r.jsx)(t.strong,{children:"Trajectory generation"}),' adds time: "reach (1,2) at t=1s, (3,3) at t=2s" with smooth velocity/acceleration.']}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Why?"})," Motors need smooth commands. Abrupt changes cause vibration, wear, instability."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Time"}),": 60 minutes"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"1-path-vs-trajectory",children:"1. Path vs Trajectory"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Concept"}),(0,r.jsx)(t.th,{children:"Definition"}),(0,r.jsx)(t.th,{children:"Example"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Path"})}),(0,r.jsx)(t.td,{children:"Sequence of waypoints (geometry only)"}),(0,r.jsx)(t.td,{children:"[(0,0), (5,0), (5,5)]"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Trajectory"})}),(0,r.jsx)(t.td,{children:"Path + time parameterization"}),(0,r.jsx)(t.td,{children:"q(t): position at time t"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Velocity profile"})}),(0,r.jsx)(t.td,{children:"Speed along path"}),(0,r.jsx)(t.td,{children:"v(t): velocity at time t"})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Real robots"})," execute trajectories, not paths!"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"2-polynomial-trajectories",children:"2. Polynomial Trajectories"}),"\n",(0,r.jsx)(t.h3,{id:"cubic-polynomial-3rd-degree",children:"Cubic Polynomial (3rd degree)"}),"\n",(0,r.jsx)(t.p,{children:"For 1-DOF motion from q0 to qf in time T:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"q(t) = a0 + a1*t + a2*t^2 + a3*t^3\n"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Constraints"})," (4 equations, 4 unknowns):"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"q(0) = q0 (start position)"}),"\n",(0,r.jsx)(t.li,{children:"q(T) = qf (end position)"}),"\n",(0,r.jsx)(t.li,{children:"v(0) = 0 (start at rest)"}),"\n",(0,r.jsx)(t.li,{children:"v(T) = 0 (end at rest)"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Solve"}),": Find a0, a1, a2, a3 satisfying constraints."]}),"\n",(0,r.jsx)(t.h3,{id:"quintic-polynomial-5th-degree",children:"Quintic Polynomial (5th degree)"}),"\n",(0,r.jsx)(t.p,{children:"Adds acceleration constraints:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"a(0) = 0 (start with zero acceleration)"}),"\n",(0,r.jsx)(t.li,{children:"a(T) = 0 (end with zero acceleration)"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"More DOFs"}),": Smoother motion, less jerk."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"3-minimum-jerk-trajectories",children:"3. Minimum-Jerk Trajectories"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Jerk"})," = rate of change of acceleration (d\xb3q/dt\xb3)."]}),"\n",(0,r.jsx)(t.p,{children:"High jerk causes:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Motor stress"}),"\n",(0,r.jsx)(t.li,{children:"Vibration"}),"\n",(0,r.jsx)(t.li,{children:"Inaccuracy"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Minimum-jerk trajectory"}),": Minimize \u222b jerk\xb2 dt over [0, T]."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Result"}),": Natural, human-like motion (humans minimize jerk unconsciously!)."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"4-time-optimal-trajectories",children:"4. Time-Optimal Trajectories"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Goal"}),": Reach goal as fast as possible while respecting:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Max velocity: |v| \u2264 v_max"}),"\n",(0,r.jsx)(t.li,{children:"Max acceleration: |a| \u2264 a_max"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Bang-bang control"}),": Accelerate at max, coast, decelerate at max."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Trade-off"}),": Speed vs smoothness (jerk increases)."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"5-exercises",children:"5. Exercises"}),"\n",(0,r.jsx)(t.h3,{id:"exercise-531-cubic-polynomial-trajectory",children:"Exercise 5.3.1: Cubic Polynomial Trajectory"}),"\n",(0,r.jsx)(t.p,{children:"Generate cubic polynomial for 1-DOF joint motion."}),"\n",(0,r.jsx)(i,{id:"ex-5-3-1",title:"Cubic Polynomial Trajectory",starterCode:'import numpy as np\n\ndef cubic_trajectory(q0: float, qf: float, T: float, t: float) -> float:\n  """Compute position at time t using cubic polynomial.\n\n  Constraints:\n      q(0) = q0, q(T) = qf\n      v(0) = 0, v(T) = 0\n\n  Args:\n      q0: Start position\n      qf: End position\n      T: Total time\n      t: Current time (0 <= t <= T)\n\n  Returns:\n      Position at time t\n  """\n  # Coefficients for cubic: q(t) = a0 + a1*t + a2*t^2 + a3*t^3\n  # From constraints:\n  # a0 = q0\n  # a1 = 0\n  # a2 = 3*(qf - q0) / T^2\n  # a3 = -2*(qf - q0) / T^3\n\n  # TODO: Implement cubic trajectory\n  pass\n\n# Test\nq0, qf, T = 0.0, 1.0, 2.0\ntimes = np.linspace(0, T, 100)\npositions = [cubic_trajectory(q0, qf, T, t) for t in times]\nprint(f"Start: {positions[0]:.3f}, End: {positions[-1]:.3f}")\n',hints:["a0 = q0","a1 = 0 (zero initial velocity)","a2 = 3*(qf - q0) / (T**2)","a3 = -2*(qf - q0) / (T**3)","return a0 + a1*t + a2*t**2 + a3*t**3"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"exercise-532-velocity-profile",children:"Exercise 5.3.2: Velocity Profile"}),"\n",(0,r.jsx)(t.p,{children:"Compute velocity from cubic trajectory."}),"\n",(0,r.jsx)(i,{id:"ex-5-3-2",title:"Velocity Profile",starterCode:'import numpy as np\n\ndef cubic_velocity(q0: float, qf: float, T: float, t: float) -> float:\n  """Compute velocity at time t (derivative of cubic trajectory).\n\n  Args:\n      q0: Start position\n      qf: End position\n      T: Total time\n      t: Current time\n\n  Returns:\n      Velocity at time t\n  """\n  # v(t) = dq/dt = a1 + 2*a2*t + 3*a3*t^2\n  # TODO: Compute velocity using derivative\n  pass\n\n# Test\nq0, qf, T = 0.0, 1.0, 2.0\ntimes = np.linspace(0, T, 100)\nvelocities = [cubic_velocity(q0, qf, T, t) for t in times]\nprint(f"Start vel: {velocities[0]:.3f}, End vel: {velocities[-1]:.3f}")\nprint(f"Max vel: {max(velocities):.3f}")\n',hints:["Use same a2, a3 from cubic_trajectory","a1 = 0","return a1 + 2*a2*t + 3*a3*t**2"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"exercise-533-quintic-trajectory",children:"Exercise 5.3.3: Quintic Trajectory"}),"\n",(0,r.jsx)(t.p,{children:"Generate quintic polynomial with acceleration constraints."}),"\n",(0,r.jsx)(i,{id:"ex-5-3-3",title:"Quintic Polynomial Trajectory",starterCode:'import numpy as np\n\ndef quintic_trajectory(q0: float, qf: float, T: float, t: float) -> float:\n  """Quintic polynomial with zero boundary velocities and accelerations.\n\n  Constraints:\n      q(0) = q0, q(T) = qf\n      v(0) = 0, v(T) = 0\n      a(0) = 0, a(T) = 0\n\n  Returns:\n      Position at time t\n  """\n  # Quintic: q(t) = a0 + a1*t + a2*t^2 + a3*t^3 + a4*t^4 + a5*t^5\n  # From 6 constraints:\n  a0 = q0\n  a1 = 0.0\n  a2 = 0.0\n  a3 = 10.0 * (qf - q0) / (T ** 3)\n  a4 = -15.0 * (qf - q0) / (T ** 4)\n  a5 = 6.0 * (qf - q0) / (T ** 5)\n\n  # TODO: Return quintic polynomial value\n  pass\n\n# Test\nq0, qf, T = 0.0, 1.0, 2.0\ntimes = np.linspace(0, T, 100)\npositions = [quintic_trajectory(q0, qf, T, t) for t in times]\nprint(f"Start: {positions[0]:.3f}, End: {positions[-1]:.3f}")\n',hints:["return a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 + a5*t**5"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"exercise-534-multi-waypoint-trajectory",children:"Exercise 5.3.4: Multi-Waypoint Trajectory"}),"\n",(0,r.jsx)(t.p,{children:"Connect multiple waypoints with smooth trajectories."}),"\n",(0,r.jsx)(i,{id:"ex-5-3-4",title:"Multi-Waypoint Trajectory",starterCode:'import numpy as np\n\ndef multi_waypoint_trajectory(waypoints, times, t):\n  """Generate trajectory through multiple waypoints.\n\n  Args:\n      waypoints: List of positions [q0, q1, q2, ...]\n      times: List of times [0, t1, t2, ...] for each waypoint\n      t: Current time\n\n  Returns:\n      Position at time t\n  """\n  # TODO: Find which segment t belongs to\n  # Apply cubic_trajectory for that segment\n  # Hint: Use cubic_trajectory(qi, qi+1, Ti, t_local)\n\n  pass\n\n# Test\nwaypoints = [0.0, 1.0, 0.5, 1.5]\ntimes = [0.0, 1.0, 2.0, 3.0]\ntest_times = np.linspace(0, 3, 100)\ntraj = [multi_waypoint_trajectory(waypoints, times, t) for t in test_times]\nprint(f"Trajectory length: {len(traj)}")\n',hints:["Find segment: for i in range(len(times)-1): if times[i] <= t <= times[i+1]","Local time: t_local = t - times[i]","Segment duration: T_seg = times[i+1] - times[i]","return cubic_trajectory(waypoints[i], waypoints[i+1], T_seg, t_local)"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"6-try-with-ai",children:"6. Try With AI"}),"\n",(0,r.jsx)(t.h3,{id:"trywithai-531-trajectory-smoothness-analysis",children:"TryWithAI 5.3.1: Trajectory Smoothness Analysis"}),"\n",(0,r.jsx)(s,{id:"tryai-5-3-1",title:"Compare Cubic vs Quintic Smoothness",role:"Teacher",scenario:"You want to understand when to use cubic vs quintic polynomials",yourTask:"Implement both cubic and quintic trajectories for same motion, compare results",aiPromptTemplate:"I implemented cubic and quintic trajectories for moving from 0 to 1 in 2 seconds. Here's what I observe: [describe position/velocity/acceleration plots or values]. Can you explain: (1) Why quintic is smoother? (2) When would I prefer cubic for simplicity? (3) What happens if I need to pass through intermediate waypoints?",successCriteria:["You understand quintic has smoother acceleration (zero jerk at boundaries)","You can identify when extra smoothness is worth the complexity","You understand waypoint constraints affect polynomial choice"],reflectionQuestions:["What is jerk and why does it matter for motors?","How would you handle velocity constraints at waypoints?"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"trywithai-532-time-optimal-trajectory-design",children:"TryWithAI 5.3.2: Time-Optimal Trajectory Design"}),"\n",(0,r.jsx)(s,{id:"tryai-5-3-2",title:"Design Time-Optimal Motion",role:"Evaluator",scenario:"You need fastest possible motion with velocity/acceleration limits",yourTask:"Design a bang-bang trajectory for 1-DOF motion with v_max=2.0, a_max=1.0",aiPromptTemplate:"I want to move from 0 to 10 meters as fast as possible with v_max=2.0 m/s and a_max=1.0 m/s\xb2. I think the trajectory should: [describe your approach: accelerate/coast/decelerate phases]. Can you verify: (1) Is my time calculation correct? (2) Do I violate constraints? (3) How does this compare to a smooth polynomial trajectory?",successCriteria:["You can compute minimum time analytically","You understand bang-bang creates non-smooth jerk","You can identify trade-off between speed and smoothness"],reflectionQuestions:["When would you sacrifice time-optimality for smoothness?","How do you handle cases where coast phase duration is zero?"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Key Takeaways"}),":"]}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Path \u2260 Trajectory"}),": Add time parameterization for execution"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Cubic polynomial"}),": 4 constraints (position + velocity boundaries)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Quintic polynomial"}),": 6 constraints (+ acceleration boundaries, smoother)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Minimum jerk"}),": Natural motion, reduces vibration"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Time-optimal"}),": Bang-bang control, fast but jerky"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Trade-offs"}),": Speed vs smoothness, complexity vs performance"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"What's Next"}),": ",(0,r.jsx)(t.a,{href:"/physical-ai-book/docs/chapter-05/lesson-04-feedback-control",children:"Lesson 5.4: Feedback Control"})," ensures robots track generated trajectories accurately."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Estimated completion time"}),": 60 minutes | ",(0,r.jsx)(t.strong,{children:"Prerequisites"}),": Lesson 5.1, Chapter 2 | ",(0,r.jsx)(t.strong,{children:"Difficulty"}),": B2 (Upper Intermediate)"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}function m(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>a});var n=i(6540);const r={},o=n.createContext(r);function s(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);