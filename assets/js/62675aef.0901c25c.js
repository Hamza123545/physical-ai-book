if(void 0===__webpack_require__)var __webpack_require__={};(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3097],{1006:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"chapter-05/lesson-04-feedback-control","title":"Lesson 5.4: Feedback Control","description":"Design PID and state-space controllers for trajectory tracking","source":"@site/docs/chapter-05/lesson-04-feedback-control.md","sourceDirName":"chapter-05","slug":"/chapter-05/lesson-04-feedback-control","permalink":"/physical-ai-book/docs/chapter-05/lesson-04-feedback-control","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"pid","permalink":"/physical-ai-book/docs/tags/pid"},{"inline":true,"label":"feedback-control","permalink":"/physical-ai-book/docs/tags/feedback-control"},{"inline":true,"label":"state-space","permalink":"/physical-ai-book/docs/tags/state-space"},{"inline":true,"label":"tracking","permalink":"/physical-ai-book/docs/tags/tracking"}],"version":"current","frontMatter":{"title":"Lesson 5.4: Feedback Control","description":"Design PID and state-space controllers for trajectory tracking","chapter":5,"lesson":4,"estimated_time":60,"cefr_level":"B2","blooms_level":"Apply","digcomp_level":6,"generated_by":"claude-sonnet-4-5-20250929","source_spec":"specs/002-physical-ai-textbook/spec.md","created":"2025-11-29","last_modified":"2025-11-29","git_author":"claude","workflow":"/sp.implement","version":"1.0","prerequisites":["chapter-05/lesson-03-trajectory-generation","chapter-01/lesson-04-python-robotics-intro"],"has_interactive_python":true,"interactive_python_count":3,"has_try_with_ai":true,"try_with_ai_count":2,"tags":["pid","feedback-control","state-space","tracking"]},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 5.3: Trajectory Generation","permalink":"/physical-ai-book/docs/chapter-05/lesson-03-trajectory-generation"},"next":{"title":"Lesson 5.5: Model Predictive Control","permalink":"/physical-ai-book/docs/chapter-05/lesson-05-mpc"}}');var i=t(4848),s=t(8453);const o={title:"Lesson 5.4: Feedback Control",description:"Design PID and state-space controllers for trajectory tracking",chapter:5,lesson:4,estimated_time:60,cefr_level:"B2",blooms_level:"Apply",digcomp_level:6,generated_by:"claude-sonnet-4-5-20250929",source_spec:"specs/002-physical-ai-textbook/spec.md",created:"2025-11-29",last_modified:"2025-11-29",git_author:"claude",workflow:"/sp.implement",version:"1.0",prerequisites:["chapter-05/lesson-03-trajectory-generation","chapter-01/lesson-04-python-robotics-intro"],has_interactive_python:!0,interactive_python_count:3,has_try_with_ai:!0,try_with_ai_count:2,tags:["pid","feedback-control","state-space","tracking"]},l="Lesson 5.4: Feedback Control",a={},c=[{value:"\ud83c\udfaf Learning Objectives",id:"-learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. Feedback Control Loop",id:"1-feedback-control-loop",level:2},{value:"Open-Loop vs Closed-Loop",id:"open-loop-vs-closed-loop",level:3},{value:"2. PID Control",id:"2-pid-control",level:2},{value:"Proportional-Integral-Derivative",id:"proportional-integral-derivative",level:3},{value:"Each Term&#39;s Role",id:"each-terms-role",level:3},{value:"3. PID Tuning",id:"3-pid-tuning",level:2},{value:"Ziegler-Nichols Method",id:"ziegler-nichols-method",level:3},{value:"Manual Tuning",id:"manual-tuning",level:3},{value:"4. State-Space Control",id:"4-state-space-control",level:2},{value:"State Representation",id:"state-representation",level:3},{value:"State Feedback",id:"state-feedback",level:3},{value:"5. Exercises",id:"5-exercises",level:2},{value:"Exercise 5.4.1: PID Controller",id:"exercise-541-pid-controller",level:3},{value:"Exercise 5.4.2: PID Simulation",id:"exercise-542-pid-simulation",level:3},{value:"Exercise 5.4.3: State-Space Controller",id:"exercise-543-state-space-controller",level:3},{value:"6. Try With AI",id:"6-try-with-ai",level:2},{value:"TryWithAI 5.4.1: PID Tuning Strategies",id:"trywithai-541-pid-tuning-strategies",level:3},{value:"TryWithAI 5.4.2: Compare PID vs State-Space",id:"trywithai-542-compare-pid-vs-state-space",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{InteractivePython:t,LearningObjectives:r,TryWithAI:o}=n;return t||h("InteractivePython",!0),r||h("LearningObjectives",!0),o||h("TryWithAI",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"lesson-54-feedback-control",children:"Lesson 5.4: Feedback Control"})}),"\n",(0,i.jsx)(n.h2,{id:"-learning-objectives",children:"\ud83c\udfaf Learning Objectives"}),"\n",(0,i.jsx)(r,{cefr_level:"B2",objectives:[{text:"Understand feedback control principles for trajectory tracking",blooms_level:"Understand",assessment_method:"Quiz questions"},{text:"Implement PID controller with tuning for position control",blooms_level:"Apply",assessment_method:"Interactive Python exercises"},{text:"Design state-space controller for multi-variable systems",blooms_level:"Apply",assessment_method:"Interactive Python exercises"}]}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Planning"})," creates trajectories. ",(0,i.jsx)(n.strong,{children:"Control"})," makes robots follow them despite:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Motor dynamics"}),"\n",(0,i.jsx)(n.li,{children:"External disturbances (friction, gravity)"}),"\n",(0,i.jsx)(n.li,{children:"Sensor noise"}),"\n",(0,i.jsx)(n.li,{children:"Model uncertainties"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Feedback control"})," measures error and corrects it continuously."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Time"}),": 60 minutes"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"1-feedback-control-loop",children:"1. Feedback Control Loop"}),"\n",(0,i.jsx)(n.h3,{id:"open-loop-vs-closed-loop",children:"Open-Loop vs Closed-Loop"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Open-loop"}),": Send commands, hope for the best (no correction)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Command \u2192 Robot \u2192 (hope it works)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Closed-loop (feedback)"}),": Measure error, correct continuously."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Command \u2192 Error \u2192 Controller \u2192 Robot \u2192 Sensor \u2192 (loop back)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Why feedback?"})," Robustness to disturbances and model errors."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"2-pid-control",children:"2. PID Control"}),"\n",(0,i.jsx)(n.h3,{id:"proportional-integral-derivative",children:"Proportional-Integral-Derivative"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"PID"})," computes control from three error terms:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"u(t) = Kp * e(t) + Ki * \u222be(\u03c4)d\u03c4 + Kd * de/dt\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"e(t) = desired - actual"})," (error)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Kp"}),": Proportional gain (react to current error)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ki"}),": Integral gain (eliminate steady-state error)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Kd"}),": Derivative gain (dampen oscillations)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"each-terms-role",children:"Each Term's Role"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"P (Proportional)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["React to ",(0,i.jsx)(n.em,{children:"current"})," error"]}),"\n",(0,i.jsx)(n.li,{children:"Too high: oscillations"}),"\n",(0,i.jsx)(n.li,{children:"Too low: slow response"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"I (Integral)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Eliminate ",(0,i.jsx)(n.em,{children:"accumulated"})," error (steady-state offset)"]}),"\n",(0,i.jsx)(n.li,{children:"Too high: overshoot, instability"}),"\n",(0,i.jsx)(n.li,{children:"Too low: never reaches target"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"D (Derivative)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Dampen ",(0,i.jsx)(n.em,{children:"rate of change"})]}),"\n",(0,i.jsx)(n.li,{children:"Reduce overshoot"}),"\n",(0,i.jsx)(n.li,{children:"Too high: amplifies noise"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"3-pid-tuning",children:"3. PID Tuning"}),"\n",(0,i.jsx)(n.h3,{id:"ziegler-nichols-method",children:"Ziegler-Nichols Method"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Set Ki=0, Kd=0"}),"\n",(0,i.jsx)(n.li,{children:"Increase Kp until oscillations start (Kp_crit)"}),"\n",(0,i.jsx)(n.li,{children:"Measure oscillation period T_crit"}),"\n",(0,i.jsxs)(n.li,{children:["Use formulas:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Kp = 0.6 * Kp_crit"}),"\n",(0,i.jsx)(n.li,{children:"Ki = 2 * Kp / T_crit"}),"\n",(0,i.jsx)(n.li,{children:"Kd = Kp * T_crit / 8"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"manual-tuning",children:"Manual Tuning"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Start with Kp only (Ki=0, Kd=0)"}),"\n",(0,i.jsx)(n.li,{children:"Add Kd to reduce overshoot"}),"\n",(0,i.jsx)(n.li,{children:"Add Ki to eliminate steady-state error"}),"\n",(0,i.jsx)(n.li,{children:"Iterate"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"4-state-space-control",children:"4. State-Space Control"}),"\n",(0,i.jsx)(n.h3,{id:"state-representation",children:"State Representation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"State vector"}),": x = [position, velocity]\u1d40"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"System dynamics"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u1e8b = A*x + B*u  (state update)\ny = C*x        (output)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example"})," (mass on spring):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"x = [position, velocity]\u1d40\nu = force\nA = [[0, 1], [-k/m, -b/m]]\nB = [[0], [1/m]]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"state-feedback",children:"State Feedback"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Control law"}),": u = -K*x (K = gain matrix)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Goal"}),": Choose K such that system is stable and responsive."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LQR (Linear Quadratic Regulator)"}),": Optimal K that minimizes cost function."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"5-exercises",children:"5. Exercises"}),"\n",(0,i.jsx)(n.h3,{id:"exercise-541-pid-controller",children:"Exercise 5.4.1: PID Controller"}),"\n",(0,i.jsx)(n.p,{children:"Implement PID controller for position tracking."}),"\n",(0,i.jsx)(t,{id:"ex-5-4-1",title:"PID Position Controller",starterCode:'import numpy as np\n\nclass PIDController:\n  def __init__(self, Kp: float, Ki: float, Kd: float, dt: float):\n      """Initialize PID controller.\n\n      Args:\n          Kp: Proportional gain\n          Ki: Integral gain\n          Kd: Derivative gain\n          dt: Time step\n      """\n      self.Kp = Kp\n      self.Ki = Ki\n      self.Kd = Kd\n      self.dt = dt\n      self.integral = 0.0\n      self.prev_error = 0.0\n\n  def compute(self, setpoint: float, measurement: float) -> float:\n      """Compute PID control output.\n\n      Args:\n          setpoint: Desired value\n          measurement: Actual measured value\n\n      Returns:\n          Control signal\n      """\n      # TODO: Implement PID\n      # 1. Compute error\n      # 2. Update integral\n      # 3. Compute derivative\n      # 4. Return Kp*error + Ki*integral + Kd*derivative\n      pass\n\n# Test\npid = PIDController(Kp=1.0, Ki=0.1, Kd=0.05, dt=0.01)\nsetpoint = 1.0\nmeasurement = 0.5\ncontrol = pid.compute(setpoint, measurement)\nprint(f"Control output: {control:.3f}")\n',hints:["error = setpoint - measurement","self.integral += error * self.dt","derivative = (error - self.prev_error) / self.dt","self.prev_error = error","return self.Kp*error + self.Ki*self.integral + self.Kd*derivative"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"exercise-542-pid-simulation",children:"Exercise 5.4.2: PID Simulation"}),"\n",(0,i.jsx)(n.p,{children:"Simulate PID controlling a first-order system."}),"\n",(0,i.jsx)(t,{id:"ex-5-4-2",title:"PID Trajectory Tracking Simulation",starterCode:'import numpy as np\n\ndef simulate_pid_control(setpoint, duration, dt, Kp, Ki, Kd):\n  """Simulate PID controlling a simple system.\n\n  System: dv/dt = u (velocity control with force)\n          dx/dt = v (position from velocity)\n\n  Args:\n      setpoint: Target position\n      duration: Simulation time\n      dt: Time step\n      Kp, Ki, Kd: PID gains\n\n  Returns:\n      times, positions arrays\n  """\n  position = 0.0\n  velocity = 0.0\n  integral = 0.0\n  prev_error = 0.0\n\n  times = []\n  positions = []\n\n  # TODO: Simulate for duration\n  # At each step:\n  #   1. Compute PID control\n  #   2. Update velocity: v += u * dt\n  #   3. Update position: x += v * dt\n  #   4. Record time and position\n  pass\n\n# Test\ntimes, positions = simulate_pid_control(\n  setpoint=1.0, duration=5.0, dt=0.01, Kp=2.0, Ki=0.5, Kd=1.0\n)\nprint(f"Final position: {positions[-1]:.3f} (target: 1.0)")\nprint(f"Steady-state error: {abs(1.0 - positions[-1]):.4f}")\n',hints:["t = 0.0; while t < duration:","error = setpoint - position","integral += error * dt","derivative = (error - prev_error) / dt","u = Kp*error + Ki*integral + Kd*derivative","velocity += u * dt","position += velocity * dt","times.append(t); positions.append(position); t += dt"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"exercise-543-state-space-controller",children:"Exercise 5.4.3: State-Space Controller"}),"\n",(0,i.jsx)(n.p,{children:"Implement state feedback controller."}),"\n",(0,i.jsx)(t,{id:"ex-5-4-3",title:"State-Space Feedback Controller",starterCode:'import numpy as np\n\ndef state_feedback_control(x: np.ndarray, K: np.ndarray, x_desired: np.ndarray) -> float:\n  """Compute state feedback control: u = -K * (x - x_desired).\n\n  Args:\n      x: Current state vector [position, velocity]\n      K: Gain vector [Kp, Kd]\n      x_desired: Desired state [pos_desired, vel_desired]\n\n  Returns:\n      Control signal\n  """\n  # TODO: Compute u = -K * (x - x_desired)\n  # Hint: Use np.dot for matrix multiplication\n  pass\n\n# Test\nx = np.array([0.5, 0.1])  # Current: pos=0.5, vel=0.1\nx_desired = np.array([1.0, 0.0])  # Desired: pos=1.0, vel=0.0\nK = np.array([2.0, 0.5])  # Gains: Kp=2.0, Kd=0.5\n\nu = state_feedback_control(x, K, x_desired)\nprint(f"Control output: {u:.3f}")\n',hints:["error = x - x_desired","u = -np.dot(K, error)","return u"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"6-try-with-ai",children:"6. Try With AI"}),"\n",(0,i.jsx)(n.h3,{id:"trywithai-541-pid-tuning-strategies",children:"TryWithAI 5.4.1: PID Tuning Strategies"}),"\n",(0,i.jsx)(o,{id:"tryai-5-4-1",title:"Learn PID Tuning",role:"Teacher",scenario:"You need to tune a PID controller for a new system",yourTask:"Run Exercise 5.4.2 with different PID gains and observe behavior",aiPromptTemplate:"I tested PID control with these gains: [Kp, Ki, Kd] = [your values]. I observed: [describe response: overshoot, oscillation, steady-state error]. Can you explain: (1) Why this happened? (2) Which gain should I adjust and in what direction? (3) What are common signs of poor tuning?",successCriteria:["You can identify overshoot, oscillation, and steady-state error symptoms","You understand which gain to adjust for each symptom","You can achieve <5% steady-state error and <20% overshoot"],reflectionQuestions:["What happens if Kd is too high with noisy sensors?","Why might integral windup occur and how to prevent it?"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"trywithai-542-compare-pid-vs-state-space",children:"TryWithAI 5.4.2: Compare PID vs State-Space"}),"\n",(0,i.jsx)(o,{id:"tryai-5-4-2",title:"PID vs State Feedback Trade-offs",role:"Evaluator",scenario:"You want to choose between PID and state-space control",yourTask:"Implement both controllers for the same system, compare performance",aiPromptTemplate:"I implemented both PID and state-space controllers for [describe system]. PID gave [describe performance], state-space gave [describe performance]. Can you explain: (1) When is PID sufficient? (2) When do you need state-space? (3) What are implementation trade-offs (complexity, tuning, observability)?",successCriteria:["You understand PID is simpler but limited to SISO (single input, single output)","You understand state-space handles MIMO (multiple inputs, multiple outputs)","You can identify when model-based control (state-space) is worth complexity"],reflectionQuestions:["How do you get full state feedback if you can't measure velocity?","What is an observer/estimator and when do you need one?"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Takeaways"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback control"}),": Measure error, correct continuously (robustness)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PID"}),": Simple, effective for many systems","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"P: current error"}),"\n",(0,i.jsx)(n.li,{children:"I: accumulated error (steady-state)"}),"\n",(0,i.jsx)(n.li,{children:"D: rate of change (damping)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tuning"}),": Ziegler-Nichols or manual (start P, add D, add I)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State-space"}),": Model-based, optimal (LQR), handles MIMO"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Trade-offs"}),": Simplicity (PID) vs optimality (state-space)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What's Next"}),": ",(0,i.jsx)(n.a,{href:"/physical-ai-book/docs/chapter-05/lesson-05-mpc",children:"Lesson 5.5: Model Predictive Control"})," optimizes control over future horizon."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Estimated completion time"}),": 60 minutes | ",(0,i.jsx)(n.strong,{children:"Prerequisites"}),": Lesson 5.3, Chapter 1 | ",(0,i.jsx)(n.strong,{children:"Difficulty"}),": B2 (Upper Intermediate)"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var r=t(6540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);