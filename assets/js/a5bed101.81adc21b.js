if(void 0===__webpack_require__)var __webpack_require__={};(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3170],{4888:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"chapter-05/lesson-01-path-planning","title":"Lesson 5.1: Path Planning Basics","description":"Learn grid-based path planning with A* algorithm","source":"@site/docs/chapter-05/lesson-01-path-planning.md","sourceDirName":"chapter-05","slug":"/chapter-05/lesson-01-path-planning","permalink":"/physical-ai-book/docs/chapter-05/lesson-01-path-planning","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"path-planning","permalink":"/physical-ai-book/docs/tags/path-planning"},{"inline":true,"label":"a-star","permalink":"/physical-ai-book/docs/tags/a-star"},{"inline":true,"label":"grid-search","permalink":"/physical-ai-book/docs/tags/grid-search"},{"inline":true,"label":"dijkstra","permalink":"/physical-ai-book/docs/tags/dijkstra"}],"version":"current","frontMatter":{"title":"Lesson 5.1: Path Planning Basics","description":"Learn grid-based path planning with A* algorithm","chapter":5,"lesson":1,"estimated_time":60,"cefr_level":"B2","blooms_level":"Apply","digcomp_level":6,"generated_by":"claude-sonnet-4-5-20250929","source_spec":"specs/002-physical-ai-textbook/spec.md","created":"2025-11-29","last_modified":"2025-11-29","git_author":"claude","workflow":"/sp.implement","version":"1.0","prerequisites":["chapter-01/lesson-04-python-robotics-intro"],"has_interactive_python":true,"interactive_python_count":3,"has_try_with_ai":true,"try_with_ai_count":2,"tags":["path-planning","a-star","grid-search","dijkstra"]},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 5 Quiz","permalink":"/physical-ai-book/docs/chapter-05/quiz"},"next":{"title":"Lesson 5.2: Sampling-Based Planning","permalink":"/physical-ai-book/docs/chapter-05/lesson-02-sampling-planning"}}');var t=i(4848),r=i(8453);const a={title:"Lesson 5.1: Path Planning Basics",description:"Learn grid-based path planning with A* algorithm",chapter:5,lesson:1,estimated_time:60,cefr_level:"B2",blooms_level:"Apply",digcomp_level:6,generated_by:"claude-sonnet-4-5-20250929",source_spec:"specs/002-physical-ai-textbook/spec.md",created:"2025-11-29",last_modified:"2025-11-29",git_author:"claude",workflow:"/sp.implement",version:"1.0",prerequisites:["chapter-01/lesson-04-python-robotics-intro"],has_interactive_python:!0,interactive_python_count:3,has_try_with_ai:!0,try_with_ai_count:2,tags:["path-planning","a-star","grid-search","dijkstra"]},o="Lesson 5.1: Path Planning Basics",l={},c=[{value:"\ud83c\udfaf Learning Objectives",id:"-learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. Grid Representation",id:"1-grid-representation",level:2},{value:"Occupancy Grid",id:"occupancy-grid",level:3},{value:"2. Search Algorithms",id:"2-search-algorithms",level:2},{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:3},{value:"Greedy Best-First Search",id:"greedy-best-first-search",level:3},{value:"A* Algorithm",id:"a-algorithm",level:3},{value:"3. A* Algorithm Steps",id:"3-a-algorithm-steps",level:2},{value:"4. Exercises",id:"4-exercises",level:2},{value:"Exercise 5.1.1: Manhattan Heuristic",id:"exercise-511-manhattan-heuristic",level:3},{value:"Exercise 5.1.2: Get Neighbors",id:"exercise-512-get-neighbors",level:3},{value:"Exercise 5.1.3: Simple A* Implementation",id:"exercise-513-simple-a-implementation",level:3},{value:"5. Try With AI",id:"5-try-with-ai",level:2},{value:"TryWithAI 5.1.1: Compare Search Algorithms",id:"trywithai-511-compare-search-algorithms",level:3},{value:"TryWithAI 5.1.2: Debug A* Implementation",id:"trywithai-512-debug-a-implementation",level:3},{value:"Summary",id:"summary",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{InteractivePython:i,LearningObjectives:s,TryWithAI:a}=n;return i||p("InteractivePython",!0),s||p("LearningObjectives",!0),a||p("TryWithAI",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"lesson-51-path-planning-basics",children:"Lesson 5.1: Path Planning Basics"})}),"\n",(0,t.jsx)(n.h2,{id:"-learning-objectives",children:"\ud83c\udfaf Learning Objectives"}),"\n",(0,t.jsx)(s,{cefr_level:"B2",objectives:[{text:"Understand grid-based path planning and search algorithms",blooms_level:"Understand",assessment_method:"Quiz questions"},{text:"Implement A* pathfinding algorithm in Python",blooms_level:"Apply",assessment_method:"Interactive Python exercises"},{text:"Compare Dijkstra, Greedy Best-First, and A* search strategies",blooms_level:"Analyze",assessment_method:"TryWithAI exercises"}]}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Path Planning"})," answers: ",(0,t.jsx)(n.em,{children:"How do we get from A to B without hitting obstacles?"})]}),"\n",(0,t.jsx)(n.p,{children:"Grid-based methods discretize space into cells (free or occupied), then search for collision-free paths using graph algorithms."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time"}),": 60 minutes"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"1-grid-representation",children:"1. Grid Representation"}),"\n",(0,t.jsx)(n.h3,{id:"occupancy-grid",children:"Occupancy Grid"}),"\n",(0,t.jsx)(n.p,{children:"Represent 2D space as a grid where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"0"})," = free cell"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"1"})," = obstacle"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"grid = [\n    [0, 0, 0, 1, 0],\n    [0, 1, 0, 1, 0],\n    [0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0]\n]\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Robot moves"}),": 4-connected (up/down/left/right) or 8-connected (+ diagonals)."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"2-search-algorithms",children:"2. Search Algorithms"}),"\n",(0,t.jsx)(n.h3,{id:"dijkstras-algorithm",children:"Dijkstra's Algorithm"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Explores uniformly in all directions"}),"\n",(0,t.jsx)(n.li,{children:"Guarantees shortest path"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost"}),": Distance from start"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"greedy-best-first-search",children:"Greedy Best-First Search"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Heads straight toward goal (uses heuristic)"}),"\n",(0,t.jsx)(n.li,{children:"Fast but NOT optimal"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost"}),": Estimated distance to goal"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"a-algorithm",children:"A* Algorithm"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Best of both"}),": Uses cost-so-far + heuristic"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Formula"}),": ",(0,t.jsx)(n.code,{children:"f(n) = g(n) + h(n)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"g(n)"})," = cost from start to node n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"h(n)"})," = heuristic (estimated cost from n to goal)"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Optimal"})," if heuristic is admissible (never overestimates)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Common heuristics"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Manhattan distance: ",(0,t.jsx)(n.code,{children:"|x1 - x2| + |y1 - y2|"})," (4-connected)"]}),"\n",(0,t.jsxs)(n.li,{children:["Euclidean distance: ",(0,t.jsx)(n.code,{children:"\u221a((x1-x2)\xb2 + (y1-y2)\xb2)"})," (8-connected)"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"3-a-algorithm-steps",children:"3. A* Algorithm Steps"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Initialize"}),": Add start to open_set with f=0"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Loop"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pop node with lowest f-score"}),"\n",(0,t.jsx)(n.li,{children:"If goal reached, reconstruct path and return"}),"\n",(0,t.jsxs)(n.li,{children:["For each neighbor:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If obstacle, skip"}),"\n",(0,t.jsx)(n.li,{children:"Compute g_new = g_current + cost(current, neighbor)"}),"\n",(0,t.jsx)(n.li,{children:"If g_new better than previous, update and add to open_set"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Return"}),": Path from start to goal"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"4-exercises",children:"4. Exercises"}),"\n",(0,t.jsx)(n.h3,{id:"exercise-511-manhattan-heuristic",children:"Exercise 5.1.1: Manhattan Heuristic"}),"\n",(0,t.jsx)(n.p,{children:"Implement Manhattan distance heuristic for A*."}),"\n",(0,t.jsx)(i,{id:"ex-5-1-1",title:"Manhattan Distance Heuristic",starterCode:'def manhattan_heuristic(pos, goal):\n  """Compute Manhattan distance from pos to goal."""\n  # TODO: Return |x1 - x2| + |y1 - y2|\n  # Hint: pos and goal are tuples (x, y)\n  pass\n\n# Test\nprint(manhattan_heuristic((0, 0), (3, 4)))  # Should be 7\nprint(manhattan_heuristic((2, 3), (2, 3)))  # Should be 0\n',hints:["Extract coordinates: x1, y1 = pos; x2, y2 = goal","Return abs(x1 - x2) + abs(y1 - y2)"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"exercise-512-get-neighbors",children:"Exercise 5.1.2: Get Neighbors"}),"\n",(0,t.jsx)(n.p,{children:"Get valid neighbors (not obstacles, not out-of-bounds)."}),"\n",(0,t.jsx)(i,{id:"ex-5-1-2",title:"Get Valid Neighbors",starterCode:'def get_neighbors(grid, pos):\n  """Return valid 4-connected neighbors."""\n  rows, cols = len(grid), len(grid[0])\n  x, y = pos\n  neighbors = []\n\n  # TODO: Check up, down, left, right\n  # Add neighbor if: in bounds AND grid[nx][ny] == 0\n  # Hint: directions = [(0,1), (0,-1), (1,0), (-1,0)]\n  pass\n\n# Test\ngrid = [[0, 0, 1], [0, 1, 0], [0, 0, 0]]\nprint(get_neighbors(grid, (0, 0)))  # Should be [(0, 1), (1, 0)]\n',hints:["Loop over directions: for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]","Check bounds: 0 <= nx < rows and 0 <= ny < cols","Check free: grid[nx][ny] == 0"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"exercise-513-simple-a-implementation",children:"Exercise 5.1.3: Simple A* Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Implement A* pathfinding (simplified version)."}),"\n",(0,t.jsx)(i,{id:"ex-5-1-3",title:"A* Pathfinding",starterCode:'import heapq\n\ndef astar(grid, start, goal):\n  """Find shortest path using A*."""\n  rows, cols = len(grid), len(grid[0])\n\n  # Priority queue: (f_score, position)\n  open_set = [(0, start)]\n  came_from = {}\n  g_score = {start: 0}\n\n  def heuristic(pos):\n      return abs(pos[0] - goal[0]) + abs(pos[1] - goal[1])\n\n  while open_set:\n      _, current = heapq.heappop(open_set)\n\n      if current == goal:\n          # Reconstruct path\n          path = [current]\n          while current in came_from:\n              current = came_from[current]\n              path.append(current)\n          return path[::-1]\n\n      # TODO: Explore neighbors\n      # For each valid neighbor:\n      #   - Compute g_new = g_score[current] + 1\n      #   - If better than previous, update and push to open_set\n      # Hint: Use get_neighbors from previous exercise\n      pass\n\n  return None  # No path found\n\n# Test\ngrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\npath = astar(grid, (0, 0), (2, 2))\nprint(f"Path: {path}")\n',hints:["Get neighbors: for neighbor in get_neighbors(grid, current)","Update g: g_new = g_score[current] + 1","If neighbor not in g_score or g_new < g_score[neighbor]: update","Push to heap: heapq.heappush(open_set, (g_new + heuristic(neighbor), neighbor))"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"5-try-with-ai",children:"5. Try With AI"}),"\n",(0,t.jsx)(n.h3,{id:"trywithai-511-compare-search-algorithms",children:"TryWithAI 5.1.1: Compare Search Algorithms"}),"\n",(0,t.jsx)(a,{id:"tryai-5-1-1",title:"Search Algorithm Comparison",role:"Teacher",scenario:"You want to understand when to use different search algorithms",yourTask:"List scenarios where Dijkstra, Greedy Best-First, or A* would be preferred",aiPromptTemplate:"I think [algorithm] is best for [scenario]. Can you explain the trade-offs between Dijkstra, Greedy Best-First, and A* in terms of optimality, speed, and use cases? Give me 2 examples where each algorithm excels.",successCriteria:["You understand A* balances optimality and speed","You can identify when heuristics help or hurt performance"],reflectionQuestions:["When would Greedy Best-First fail to find a path?","Why does A* need an admissible heuristic for optimality?"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"trywithai-512-debug-a-implementation",children:"TryWithAI 5.1.2: Debug A* Implementation"}),"\n",(0,t.jsx)(a,{id:"tryai-5-1-2",title:"A* Code Review",role:"Evaluator",scenario:"You implemented A* but want to ensure correctness and efficiency",yourTask:"Complete Exercise 5.1.3 with your own implementation",aiPromptTemplate:"Here's my A* implementation: [paste code]. Review it for: (1) correctness (does it always find optimal path?), (2) edge cases (what if start=goal? no path exists?), (3) efficiency improvements. What am I missing?",successCriteria:["Your code handles start=goal case","Your code returns None when no path exists","You avoid re-exploring visited nodes"],reflectionQuestions:["How would you modify A* for 8-connected grids?","What data structure makes A* efficient?"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Takeaways"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Grid-based planning"}),": Discretize space into cells, search graph"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.em,{children:[(0,t.jsx)(n.em,{children:"A"})," = Dijkstra + Heuristic"]}),"*: Optimal and efficient with admissible h(n)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Heuristics"}),": Manhattan (4-conn), Euclidean (8-conn)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Priority queue"}),": heapq for efficient f-score ordering"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What's Next"}),": ",(0,t.jsx)(n.a,{href:"/physical-ai-book/docs/chapter-05/lesson-02-sampling-planning",children:"Lesson 5.2: Sampling-Based Planning"})," scales to high-dimensional configuration spaces."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Estimated completion time"}),": 60 minutes | ",(0,t.jsx)(n.strong,{children:"Prerequisites"}),": Chapter 1, Python basics | ",(0,t.jsx)(n.strong,{children:"Difficulty"}),": B2 (Upper Intermediate)"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}function p(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);