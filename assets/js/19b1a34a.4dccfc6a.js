if(void 0===__webpack_require__)var __webpack_require__={};(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3159],{1188:(o,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>p});const n=JSON.parse('{"id":"chapter-01/lesson-04-python-robotics-intro","title":"Lesson 1.4: Python for Robotics Introduction","description":"Master NumPy and Matplotlib for robot simulation and control loop implementation","source":"@site/docs/chapter-01/lesson-04-python-robotics-intro.md","sourceDirName":"chapter-01","slug":"/chapter-01/lesson-04-python-robotics-intro","permalink":"/physical-ai-book/docs/chapter-01/lesson-04-python-robotics-intro","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"numpy","permalink":"/physical-ai-book/docs/tags/numpy"},{"inline":true,"label":"matplotlib","permalink":"/physical-ai-book/docs/tags/matplotlib"},{"inline":true,"label":"simulation","permalink":"/physical-ai-book/docs/tags/simulation"},{"inline":true,"label":"control-loops","permalink":"/physical-ai-book/docs/tags/control-loops"}],"version":"current","frontMatter":{"title":"Lesson 1.4: Python for Robotics Introduction","description":"Master NumPy and Matplotlib for robot simulation and control loop implementation","chapter":1,"lesson":4,"estimated_time":60,"cefr_level":"B1","blooms_level":"Apply","digcomp_level":3,"generated_by":"claude-sonnet-4-5-20250929","source_spec":"specs/002-physical-ai-textbook/spec.md","created":"2025-11-29","last_modified":"2025-11-29","git_author":"hswat","workflow":"/sp.implement","version":"1.0","prerequisites":["chapter-01-lesson-01","chapter-01-lesson-02","chapter-01-lesson-03"],"has_interactive_python":true,"interactive_python_count":4,"has_try_with_ai":true,"try_with_ai_count":2,"tags":["numpy","matplotlib","simulation","control-loops"]},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 1.3: Sensors and Actuators Overview","permalink":"/physical-ai-book/docs/chapter-01/lesson-03-sensors-actuators-overview"},"next":{"title":"Chapter 2: ROS 2 Fundamentals - The Robotic Nervous System","permalink":"/physical-ai-book/docs/chapter-02/"}}');var i=t(4848),s=t(8453);const r={title:"Lesson 1.4: Python for Robotics Introduction",description:"Master NumPy and Matplotlib for robot simulation and control loop implementation",chapter:1,lesson:4,estimated_time:60,cefr_level:"B1",blooms_level:"Apply",digcomp_level:3,generated_by:"claude-sonnet-4-5-20250929",source_spec:"specs/002-physical-ai-textbook/spec.md",created:"2025-11-29",last_modified:"2025-11-29",git_author:"hswat",workflow:"/sp.implement",version:"1.0",prerequisites:["chapter-01-lesson-01","chapter-01-lesson-02","chapter-01-lesson-03"],has_interactive_python:!0,interactive_python_count:4,has_try_with_ai:!0,try_with_ai_count:2,tags:["numpy","matplotlib","simulation","control-loops"]},l="Lesson 1.4: Python for Robotics Introduction",a={},p=[{value:"\ud83c\udfaf Learning Objectives",id:"-learning-objectives",level:2},{value:"\ud83d\udcda Prerequisites",id:"-prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. Why NumPy for Robotics?",id:"1-why-numpy-for-robotics",level:2},{value:"The Problem with Python Lists",id:"the-problem-with-python-lists",level:3},{value:"The NumPy Solution",id:"the-numpy-solution",level:3},{value:"Key NumPy Operations for Robotics",id:"key-numpy-operations-for-robotics",level:3},{value:"2. Matplotlib for Visualization",id:"2-matplotlib-for-visualization",level:2},{value:"Basic Plotting",id:"basic-plotting",level:3},{value:"Multiple Plots",id:"multiple-plots",level:3},{value:"3. Control Loops",id:"3-control-loops",level:2},{value:"PID Control (Preview)",id:"pid-control-preview",level:3},{value:"4. Exercises",id:"4-exercises",level:2},{value:"Exercise 1.4.1: NumPy Array Operations",id:"exercise-141-numpy-array-operations",level:3},{value:"Exercise 1.4.2: Plotting Robot Trajectory",id:"exercise-142-plotting-robot-trajectory",level:3},{value:"Exercise 1.4.3: Simple Control Loop",id:"exercise-143-simple-control-loop",level:3},{value:"Exercise 1.4.4: 2D Robot Simulation",id:"exercise-144-2d-robot-simulation",level:3},{value:"5. Try With AI",id:"5-try-with-ai",level:2},{value:"TryWithAI 1.4.1: NumPy Vectorization",id:"trywithai-141-numpy-vectorization",level:3},{value:"TryWithAI 1.4.2: Control Loop Debugging",id:"trywithai-142-control-loop-debugging",level:3},{value:"Summary",id:"summary",level:2}];function c(o){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...o.components},{InteractivePython:t,LearningObjectives:n,Prerequisites:r,TryWithAI:l}=e;return t||h("InteractivePython",!0),n||h("LearningObjectives",!0),r||h("Prerequisites",!0),l||h("TryWithAI",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"lesson-14-python-for-robotics-introduction",children:"Lesson 1.4: Python for Robotics Introduction"})}),"\n",(0,i.jsx)(e.h2,{id:"-learning-objectives",children:"\ud83c\udfaf Learning Objectives"}),"\n",(0,i.jsx)(n,{cefr_level:"B1",objectives:[{text:"Use NumPy arrays for efficient numerical computation in robotics",blooms_level:"Apply",assessment_method:"Python exercises"},{text:"Visualize robot data using Matplotlib",blooms_level:"Apply",assessment_method:"Plotting exercise"},{text:"Implement a basic robot control loop with feedback",blooms_level:"Apply",assessment_method:"Control loop and simulation exercises"}]}),"\n",(0,i.jsx)(e.h2,{id:"-prerequisites",children:"\ud83d\udcda Prerequisites"}),"\n",(0,i.jsx)(r,{prerequisites:[{lessonId:"chapter-01-lesson-01",title:"Lesson 1.1: What is Physical AI?",link:"/docs/chapter-01/lesson-01-what-is-physical-ai"},{lessonId:"chapter-01-lesson-02",title:"Lesson 1.2: Robot vs Software AI",link:"/docs/chapter-01/lesson-02-robot-vs-software-ai"},{lessonId:"chapter-01-lesson-03",title:"Lesson 1.3: Sensors and Actuators Overview",link:"/docs/chapter-01/lesson-03-sensors-actuators-overview"}]}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(e.p,{children:"Python is the most popular language for robotics and AI. Two libraries are essential:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"NumPy"}),": Fast numerical computation with arrays"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Matplotlib"}),": Data visualization and plotting"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"In this lesson, you'll learn to use these tools to simulate and control robots. By the end, you'll build a complete robot simulation!"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time"}),": 60 minutes"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"1-why-numpy-for-robotics",children:"1. Why NumPy for Robotics?"}),"\n",(0,i.jsx)(e.h3,{id:"the-problem-with-python-lists",children:"The Problem with Python Lists"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Slow: Python lists\npositions = [1.0, 2.0, 3.0]\nvelocities = [0.5, 1.0, 1.5]\nresult = [p + v for p, v in zip(positions, velocities)]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"the-numpy-solution",children:"The NumPy Solution"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import numpy as np\n# Fast: NumPy arrays\npositions = np.array([1.0, 2.0, 3.0])\nvelocities = np.array([0.5, 1.0, 1.5])\nresult = positions + velocities  # Vectorized!\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Why NumPy is faster"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Written in C (compiled, not interpreted)"}),"\n",(0,i.jsx)(e.li,{children:"Vectorized operations (no Python loops)"}),"\n",(0,i.jsx)(e.li,{children:"Optimized for numerical computation"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"key-numpy-operations-for-robotics",children:"Key NumPy Operations for Robotics"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Creating arrays\npos = np.array([1.0, 2.0, 3.0])\nzeros = np.zeros(10)\nones = np.ones(5)\nsequence = np.arange(0, 10, 0.1)  # 0 to 10, step 0.1\n\n# Math operations\nangles = np.array([0, 30, 60, 90])\nradians = np.deg2rad(angles)\nsines = np.sin(radians)\n\n# Statistics\nmean = np.mean(data)\nstd = np.std(data)\nminimum = np.min(data)\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"2-matplotlib-for-visualization",children:"2. Matplotlib for Visualization"}),"\n",(0,i.jsx)(e.p,{children:"Robots generate lots of data. Visualization helps us understand it."}),"\n",(0,i.jsx)(e.h3,{id:"basic-plotting",children:"Basic Plotting"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import matplotlib.pyplot as plt\n\ntime = np.linspace(0, 10, 100)\nposition = np.sin(time)\n\nplt.plot(time, position)\nplt.xlabel('Time (s)')\nplt.ylabel('Position (m)')\nplt.title('Robot Position over Time')\nplt.grid(True)\nplt.show()\n"})}),"\n",(0,i.jsx)(e.h3,{id:"multiple-plots",children:"Multiple Plots"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"plt.figure(figsize=(12, 4))\n\nplt.subplot(1, 2, 1)  # 1 row, 2 cols, plot 1\nplt.plot(time, position)\nplt.title('Position')\n\nplt.subplot(1, 2, 2)  # Plot 2\nplt.plot(time, velocity)\nplt.title('Velocity')\n\nplt.tight_layout()\nplt.show()\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"3-control-loops",children:"3. Control Loops"}),"\n",(0,i.jsxs)(e.p,{children:["Robots use ",(0,i.jsx)(e.strong,{children:"feedback control loops"}),":"]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Read sensor"}),"\n",(0,i.jsx)(e.li,{children:"Calculate error (desired - actual)"}),"\n",(0,i.jsx)(e.li,{children:"Compute control command"}),"\n",(0,i.jsx)(e.li,{children:"Send to actuator"}),"\n",(0,i.jsx)(e.li,{children:"Repeat"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"pid-control-preview",children:"PID Control (Preview)"}),"\n",(0,i.jsx)(e.p,{children:"The most common controller:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"P"})," (Proportional): Response proportional to error"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"I"})," (Integral): Corrects persistent errors"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"D"})," (Derivative): Dampens oscillations"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"4-exercises",children:"4. Exercises"}),"\n",(0,i.jsx)(e.h3,{id:"exercise-141-numpy-array-operations",children:"Exercise 1.4.1: NumPy Array Operations"}),"\n",(0,i.jsx)(e.p,{children:"Master NumPy basics for robot computation."}),"\n",(0,i.jsx)(t,{id:"ex-1-4-1",title:"NumPy Arrays for Robot State",starterCode:'import numpy as np\n\ndef robot_state_update(positions, velocities, dt=0.1):\n  """\n  Update robot joint positions using velocities.\n\n  Args:\n      positions: Current joint angles (array)\n      velocities: Joint velocities (rad/s)\n      dt: Time step (seconds)\n\n  Returns:\n      New positions after dt seconds\n  """\n  # TODO: Implement position update\n  # new_position = old_position + velocity * dt\n  pass\n\n# Test with 3-joint robot\npos = np.array([0.0, 0.5, 1.0])  # radians\nvel = np.array([0.1, -0.2, 0.3])  # rad/s\n\nnew_pos = robot_state_update(pos, vel, dt=0.1)\nprint(f"Old positions: {pos}")\nprint(f"Velocities: {vel}")\nprint(f"New positions: {new_pos}")\n\n# Convert to degrees\nprint(f"New positions (deg): {np.rad2deg(new_pos)}")\n',hints:["Use NumPy array addition: new_pos = positions + velocities * dt","np.rad2deg() converts radians to degrees","No loops needed - NumPy handles arrays element-wise"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"exercise-142-plotting-robot-trajectory",children:"Exercise 1.4.2: Plotting Robot Trajectory"}),"\n",(0,i.jsx)(e.p,{children:"Visualize a robot's path over time."}),"\n",(0,i.jsx)(t,{id:"ex-1-4-2",title:"Plot Robot Trajectory",starterCode:"import numpy as np\nimport matplotlib.pyplot as plt\n\ndef simulate_trajectory(initial_pos, velocity, duration=10, dt=0.1):\n  \"\"\"\n  Simulate 1D robot motion and plot trajectory.\n\n  Args:\n      initial_pos: Starting position (m)\n      velocity: Constant velocity (m/s)\n      duration: Simulation time (s)\n      dt: Time step (s)\n\n  Returns:\n      (time_array, position_array)\n  \"\"\"\n  # TODO:\n  # 1. Create time array: np.arange(0, duration, dt)\n  # 2. Calculate positions: pos = initial_pos + velocity * time\n  # 3. Return (time, positions)\n  pass\n\n# Simulate\ntime, pos = simulate_trajectory(initial_pos=0, velocity=1.5, duration=10)\n\n# Plot\nplt.figure(figsize=(10, 4))\nplt.plot(time, pos, 'b-', linewidth=2, label='Robot position')\nplt.xlabel('Time (s)')\nplt.ylabel('Position (m)')\nplt.title('Robot 1D Motion')\nplt.grid(True)\nplt.legend()\nplt.show()\n\nprint(f\"Final position: {pos[-1]:.2f} m\")\nprint(f\"Distance traveled: {pos[-1] - pos[0]:.2f} m\")\n",hints:["time = np.arange(0, duration, dt)","positions = initial_pos + velocity * time","Return both arrays as tuple"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"exercise-143-simple-control-loop",children:"Exercise 1.4.3: Simple Control Loop"}),"\n",(0,i.jsx)(e.p,{children:"Implement proportional control to reach a target."}),"\n",(0,i.jsx)(t,{id:"ex-1-4-3",title:"Proportional Controller",starterCode:"import numpy as np\nimport matplotlib.pyplot as plt\n\ndef proportional_control(target, initial_pos=0, kp=0.5, steps=100):\n  \"\"\"\n  Simulate proportional controller reaching target.\n\n  Args:\n      target: Desired position\n      initial_pos: Starting position\n      kp: Proportional gain (0-1)\n      steps: Number of control iterations\n\n  Returns:\n      Array of positions over time\n  \"\"\"\n  positions = np.zeros(steps)\n  positions[0] = initial_pos\n\n  # TODO: Implement control loop\n  # for i in range(1, steps):\n  #     error = target - positions[i-1]\n  #     control = kp * error\n  #     positions[i] = positions[i-1] + control\n\n  pass\n\n  return positions\n\n# Test\ntarget = 10.0\npositions = proportional_control(target, initial_pos=0, kp=0.3, steps=50)\n\n# Plot\nplt.figure(figsize=(10, 4))\nplt.plot(positions, 'b-', label='Actual position')\nplt.axhline(y=target, color='r', linestyle='--', label='Target')\nplt.xlabel('Control Step')\nplt.ylabel('Position')\nplt.title('Proportional Controller Response')\nplt.legend()\nplt.grid(True)\nplt.show()\n\nprint(f\"Final position: {positions[-1]:.2f}\")\nprint(f\"Final error: {abs(target - positions[-1]):.3f}\")\n",hints:["error = target - current_position","control_output = kp * error","next_position = current_position + control_output","Store each position in the array"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"exercise-144-2d-robot-simulation",children:"Exercise 1.4.4: 2D Robot Simulation"}),"\n",(0,i.jsx)(e.p,{children:"Bring it all together: simulate a robot moving in 2D space."}),"\n",(0,i.jsx)(t,{id:"ex-1-4-4",title:"2D Robot Motion Simulation",starterCode:"import numpy as np\nimport matplotlib.pyplot as plt\n\ndef simulate_robot_2d(start_pos, velocity, duration=5, dt=0.1):\n  \"\"\"\n  Simulate robot moving in 2D plane.\n\n  Args:\n      start_pos: [x, y] starting position\n      velocity: [vx, vy] velocity vector\n      duration: Simulation time\n      dt: Time step\n\n  Returns:\n      (x_positions, y_positions)\n  \"\"\"\n  # TODO:\n  # 1. Calculate number of steps\n  # 2. Create arrays for x and y positions\n  # 3. Loop and update: pos = pos + velocity * dt\n  # 4. Return x and y arrays\n  pass\n\n# Test: Robot moves diagonally\nstart = np.array([0.0, 0.0])\nvel = np.array([1.0, 0.5])  # Moving right and up\n\nx_pos, y_pos = simulate_robot_2d(start, vel, duration=10)\n\n# Plot trajectory\nplt.figure(figsize=(8, 8))\nplt.plot(x_pos, y_pos, 'b-', linewidth=2, label='Robot path')\nplt.plot(x_pos[0], y_pos[0], 'go', markersize=10, label='Start')\nplt.plot(x_pos[-1], y_pos[-1], 'ro', markersize=10, label='End')\nplt.xlabel('X Position (m)')\nplt.ylabel('Y Position (m)')\nplt.title('2D Robot Trajectory')\nplt.grid(True)\nplt.legend()\nplt.axis('equal')\nplt.show()\n\nprint(f\"Start: ({x_pos[0]:.1f}, {y_pos[0]:.1f})\")\nprint(f\"End: ({x_pos[-1]:.1f}, {y_pos[-1]:.1f})\")\nprint(f\"Distance: {np.sqrt((x_pos[-1]-x_pos[0])**2 + (y_pos[-1]-y_pos[0])**2):.2f} m\")\n",hints:["steps = int(duration / dt)","x = np.zeros(steps), y = np.zeros(steps)","In loop: x[i] = x[i-1] + velocity[0] * dt","Similarly for y with velocity[1]"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"5-try-with-ai",children:"5. Try With AI"}),"\n",(0,i.jsx)(e.h3,{id:"trywithai-141-numpy-vectorization",children:"TryWithAI 1.4.1: NumPy Vectorization"}),"\n",(0,i.jsx)(l,{id:"tryai-1-4-1",title:"Optimize Code with NumPy Vectorization",role:"Copilot",scenario:"You have slow robot code using Python loops. You want to speed it up with NumPy vectorization.",yourTask:"Complete Exercise 1.4.1, then write a version using a Python for loop instead of NumPy array operations.",aiPromptTemplate:"I have this robot update code using loops: [paste your loop version]. Can you help me convert it to use NumPy vectorization? Explain why the NumPy version is faster.",successCriteria:["You understand the difference between loops and vectorization","You can convert loop-based code to NumPy operations","You know when vectorization provides benefits"],reflectionQuestions:["How much faster is vectorized code for 1000 joints?","Are there cases where loops are better than vectorization?","What operations can't be vectorized?"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"trywithai-142-control-loop-debugging",children:"TryWithAI 1.4.2: Control Loop Debugging"}),"\n",(0,i.jsx)(l,{id:"tryai-1-4-2",title:"Debug Control Loop Oscillations",role:"Evaluator",scenario:"Your proportional controller (Exercise 1.4.3) oscillates around the target instead of settling smoothly.",yourTask:"Run Exercise 1.4.3 with kp=0.9 (high gain). Observe the oscillations. Think about why this happens.",aiPromptTemplate:"My proportional controller oscillates with kp={kp_value}. Here's my code: [paste]. Can you review it and explain why high gain causes oscillations? Suggest how to fix it (hint: PID control).",successCriteria:["You understand how gain affects controller behavior","You can identify oscillation in plots","You know that D (derivative) term reduces oscillations"],reflectionQuestions:["What happens with very low gain (kp=0.1)?","What happens with very high gain (kp=1.5)?","How would you choose the right gain value?"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Key Takeaways"}),":"]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"NumPy for Robotics"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Arrays are faster than lists"}),"\n",(0,i.jsx)(e.li,{children:"Vectorized operations (no loops)"}),"\n",(0,i.jsxs)(e.li,{children:["Essential functions: ",(0,i.jsx)(e.code,{children:"np.array"}),", ",(0,i.jsx)(e.code,{children:"np.zeros"}),", ",(0,i.jsx)(e.code,{children:"np.sin"}),", ",(0,i.jsx)(e.code,{children:"np.mean"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Matplotlib for Visualization"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Plot trajectories and sensor data"}),"\n",(0,i.jsx)(e.li,{children:"Multiple subplots for comparison"}),"\n",(0,i.jsx)(e.li,{children:"Helps debug and understand robot behavior"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Control Loops"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Read sensor \u2192 Calculate error \u2192 Command actuator \u2192 Repeat"}),"\n",(0,i.jsx)(e.li,{children:"Proportional control: output = kp * error"}),"\n",(0,i.jsx)(e.li,{children:"Higher gain = faster response but more oscillation"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Practical Skills"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Array operations for robot states"}),"\n",(0,i.jsx)(e.li,{children:"Trajectory visualization"}),"\n",(0,i.jsx)(e.li,{children:"Implementing basic controllers"}),"\n",(0,i.jsx)(e.li,{children:"2D motion simulation"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"\ud83c\udf89 Chapter 1 Complete!"})," You now have the foundational knowledge of Physical AI:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"What makes Physical AI different"}),"\n",(0,i.jsx)(e.li,{children:"Real-time and safety requirements"}),"\n",(0,i.jsx)(e.li,{children:"Common sensors and actuators"}),"\n",(0,i.jsx)(e.li,{children:"Python tools for robotics"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What's Next"}),": Take the ",(0,i.jsx)(e.a,{href:"/physical-ai-book/docs/chapter-01/quiz",children:"Chapter 1 Quiz"})," to test your understanding, then move on to ",(0,i.jsx)(e.strong,{children:"Chapter 2: Robot Kinematics and Dynamics"})," to learn how to program robot arms!"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Estimated completion time"}),": 60 minutes | ",(0,i.jsx)(e.strong,{children:"Prerequisites"}),": Lessons 1.1, 1.2, 1.3 | ",(0,i.jsx)(e.strong,{children:"Difficulty"}),": B1 (Intermediate)"]})]})}function d(o={}){const{wrapper:e}={...(0,s.R)(),...o.components};return e?(0,i.jsx)(e,{...o,children:(0,i.jsx)(c,{...o})}):c(o)}function h(o,e){throw new Error("Expected "+(e?"component":"object")+" `"+o+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(o,e,t)=>{t.d(e,{R:()=>r,x:()=>l});var n=t(6540);const i={},s=n.createContext(i);function r(o){const e=n.useContext(s);return n.useMemo(function(){return"function"==typeof o?o(e):{...e,...o}},[e,o])}function l(o){let e;return e=o.disableParentContext?"function"==typeof o.components?o.components(i):o.components||i:r(o.components),n.createElement(s.Provider,{value:e},o.children)}}}]);