if(void 0===__webpack_require__)var __webpack_require__={};(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4594],{790:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"chapter-05/lesson-02-sampling-planning","title":"Lesson 5.2: Sampling-Based Planning","description":"Learn RRT and PRM algorithms for high-dimensional planning","source":"@site/docs/chapter-05/lesson-02-sampling-planning.md","sourceDirName":"chapter-05","slug":"/chapter-05/lesson-02-sampling-planning","permalink":"/physical-ai-book/docs/chapter-05/lesson-02-sampling-planning","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"rrt","permalink":"/physical-ai-book/docs/tags/rrt"},{"inline":true,"label":"prm","permalink":"/physical-ai-book/docs/tags/prm"},{"inline":true,"label":"sampling-based","permalink":"/physical-ai-book/docs/tags/sampling-based"},{"inline":true,"label":"motion-planning","permalink":"/physical-ai-book/docs/tags/motion-planning"}],"version":"current","frontMatter":{"title":"Lesson 5.2: Sampling-Based Planning","description":"Learn RRT and PRM algorithms for high-dimensional planning","chapter":5,"lesson":2,"estimated_time":60,"cefr_level":"B2","blooms_level":"Apply","digcomp_level":6,"generated_by":"claude-sonnet-4-5-20250929","source_spec":"specs/002-physical-ai-textbook/spec.md","created":"2025-11-29","last_modified":"2025-11-29","git_author":"claude","workflow":"/sp.implement","version":"1.0","prerequisites":["chapter-05/lesson-01-path-planning"],"has_interactive_python":true,"interactive_python_count":3,"has_try_with_ai":true,"try_with_ai_count":1,"tags":["rrt","prm","sampling-based","motion-planning"]},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 5.1: Path Planning Basics","permalink":"/physical-ai-book/docs/chapter-05/lesson-01-path-planning"},"next":{"title":"Lesson 5.3: Trajectory Generation","permalink":"/physical-ai-book/docs/chapter-05/lesson-03-trajectory-generation"}}');var r=i(4848),t=i(8453);const o={title:"Lesson 5.2: Sampling-Based Planning",description:"Learn RRT and PRM algorithms for high-dimensional planning",chapter:5,lesson:2,estimated_time:60,cefr_level:"B2",blooms_level:"Apply",digcomp_level:6,generated_by:"claude-sonnet-4-5-20250929",source_spec:"specs/002-physical-ai-textbook/spec.md",created:"2025-11-29",last_modified:"2025-11-29",git_author:"claude",workflow:"/sp.implement",version:"1.0",prerequisites:["chapter-05/lesson-01-path-planning"],has_interactive_python:!0,interactive_python_count:3,has_try_with_ai:!0,try_with_ai_count:1,tags:["rrt","prm","sampling-based","motion-planning"]},a="Lesson 5.2: Sampling-Based Planning",l={},d=[{value:"\ud83c\udfaf Learning Objectives",id:"-learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. The Curse of Dimensionality",id:"1-the-curse-of-dimensionality",level:2},{value:"Grid Explosion",id:"grid-explosion",level:3},{value:"Sampling Solution",id:"sampling-solution",level:3},{value:"2. PRM: Probabilistic Roadmap",id:"2-prm-probabilistic-roadmap",level:2},{value:"Algorithm",id:"algorithm",level:3},{value:"Properties",id:"properties",level:3},{value:"3. RRT: Rapidly-exploring Random Tree",id:"3-rrt-rapidly-exploring-random-tree",level:2},{value:"Algorithm",id:"algorithm-1",level:3},{value:"Properties",id:"properties-1",level:3},{value:"Variants",id:"variants",level:3},{value:"4. Collision Checking",id:"4-collision-checking",level:2},{value:"5. Exercises",id:"5-exercises",level:2},{value:"Exercise 5.2.1: Random Sampling",id:"exercise-521-random-sampling",level:3},{value:"Exercise 5.2.2: Nearest Neighbor",id:"exercise-522-nearest-neighbor",level:3},{value:"Exercise 5.2.3: Simple RRT",id:"exercise-523-simple-rrt",level:3},{value:"6. Try With AI",id:"6-try-with-ai",level:2},{value:"TryWithAI 5.2.1: RRT vs PRM Trade-offs",id:"trywithai-521-rrt-vs-prm-trade-offs",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{InteractivePython:i,LearningObjectives:s,TryWithAI:o}=n;return i||p("InteractivePython",!0),s||p("LearningObjectives",!0),o||p("TryWithAI",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"lesson-52-sampling-based-planning",children:"Lesson 5.2: Sampling-Based Planning"})}),"\n",(0,r.jsx)(n.h2,{id:"-learning-objectives",children:"\ud83c\udfaf Learning Objectives"}),"\n",(0,r.jsx)(s,{cefr_level:"B2",objectives:[{text:"Understand why sampling-based methods scale to high dimensions",blooms_level:"Understand",assessment_method:"Quiz questions"},{text:"Implement RRT (Rapidly-exploring Random Tree) algorithm",blooms_level:"Apply",assessment_method:"Interactive Python exercises"},{text:"Compare RRT vs PRM trade-offs for different planning problems",blooms_level:"Analyze",assessment_method:"TryWithAI exercises"}]}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.em,{children:[(0,r.jsx)(n.em,{children:"Grid-based A"})," fails"]}),"* in high dimensions (robot arms, humanoids): a 6-DOF arm with 100 cells/dimension needs 100^6 = 1 trillion cells!"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sampling-based methods"})," (RRT, PRM) randomly sample the configuration space, avoiding explicit discretization."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time"}),": 60 minutes"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"1-the-curse-of-dimensionality",children:"1. The Curse of Dimensionality"}),"\n",(0,r.jsx)(n.h3,{id:"grid-explosion",children:"Grid Explosion"}),"\n",(0,r.jsx)(n.p,{children:"For n-DOF robot with r resolution per dimension:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Grid cells"}),": r^n"]}),"\n",(0,r.jsx)(n.li,{children:"6-DOF, 100 res/dim: 10^12 cells (infeasible!)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sampling-solution",children:"Sampling Solution"}),"\n",(0,r.jsx)(n.p,{children:"Instead of discretizing:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sample random configurations"})," (e.g., 1000 samples)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Connect nearby samples"})," (collision-free edges)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Search the roadmap"})," (A* on samples)"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-prm-probabilistic-roadmap",children:"2. PRM: Probabilistic Roadmap"}),"\n",(0,r.jsx)(n.h3,{id:"algorithm",children:"Algorithm"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Learning Phase"})," (build roadmap once):"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Sample N random configurations"}),"\n",(0,r.jsx)(n.li,{children:"For each sample, try to connect to k nearest neighbors"}),"\n",(0,r.jsx)(n.li,{children:"Keep collision-free edges"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query Phase"})," (reuse roadmap):"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Connect start and goal to roadmap"}),"\n",(0,r.jsx)(n.li,{children:"Search roadmap with A*"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"properties",children:"Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-query"}),": Build once, use many times"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": Efficient for repeated queries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Slow preprocessing, may miss narrow passages"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-rrt-rapidly-exploring-random-tree",children:"3. RRT: Rapidly-exploring Random Tree"}),"\n",(0,r.jsx)(n.h3,{id:"algorithm-1",children:"Algorithm"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Initialize"}),": Tree contains only start node"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Loop"})," until goal reached:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sample random configuration q_rand"}),"\n",(0,r.jsx)(n.li,{children:"Find nearest node q_near in tree"}),"\n",(0,r.jsx)(n.li,{children:"Extend from q_near toward q_rand by step_size"}),"\n",(0,r.jsx)(n.li,{children:"If collision-free, add q_new to tree"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Return"}),": Path from start to goal"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"properties-1",children:"Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single-query"}),": Fast planning, no preprocessing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": Good for narrow passages, dynamic environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Paths not optimal (can post-process)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"variants",children:"Variants"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RRT"}),"*: Converges to optimal path"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bi-directional RRT"}),": Grow trees from start and goal"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RRT-Connect"}),": Greedy variant for faster connection"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-collision-checking",children:"4. Collision Checking"}),"\n",(0,r.jsx)(n.p,{children:"Both PRM and RRT need:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def is_collision_free(config, obstacles):\n    """Check if robot configuration collides."""\n    # For 2D point robot: check if in obstacle\n    # For arm: check all links against obstacles\n    return not in_obstacle(config)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expensive operation"}),": Dominate planning time. Optimizations matter!"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-exercises",children:"5. Exercises"}),"\n",(0,r.jsx)(n.h3,{id:"exercise-521-random-sampling",children:"Exercise 5.2.1: Random Sampling"}),"\n",(0,r.jsx)(n.p,{children:"Sample random configurations in 2D workspace."}),"\n",(0,r.jsx)(i,{id:"ex-5-2-1",title:"Random Configuration Sampling",starterCode:'import numpy as np\n\ndef sample_random_config(bounds, n_samples=100):\n  """Sample random 2D configurations within bounds.\n\n  Args:\n      bounds: ((x_min, x_max), (y_min, y_max))\n      n_samples: Number of samples\n\n  Returns:\n      Array of shape (n_samples, 2)\n  """\n  # TODO: Generate random (x, y) within bounds\n  # Hint: np.random.uniform(low, high, size)\n  pass\n\n# Test\nbounds = ((0, 10), (0, 10))\nsamples = sample_random_config(bounds, 100)\nprint(f"Samples shape: {samples.shape}")\nprint(f"First 3: {samples[:3]}")\n',hints:["x = np.random.uniform(bounds[0][0], bounds[0][1], n_samples)","y = np.random.uniform(bounds[1][0], bounds[1][1], n_samples)","return np.column_stack([x, y])"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"exercise-522-nearest-neighbor",children:"Exercise 5.2.2: Nearest Neighbor"}),"\n",(0,r.jsx)(n.p,{children:"Find nearest node in tree to a target configuration."}),"\n",(0,r.jsx)(i,{id:"ex-5-2-2",title:"Nearest Neighbor Search",starterCode:'import numpy as np\n\ndef find_nearest(tree, target):\n  """Find nearest node in tree to target.\n\n  Args:\n      tree: List of (x, y) configurations\n      target: (x, y) target configuration\n\n  Returns:\n      Index of nearest node, nearest node\n  """\n  # TODO: Compute distances to all tree nodes, return nearest\n  # Hint: np.linalg.norm for Euclidean distance\n  pass\n\n# Test\ntree = [(0, 0), (1, 1), (2, 0), (1, 2)]\ntarget = (1.5, 0.5)\nidx, nearest = find_nearest(tree, target)\nprint(f"Nearest: {nearest} at index {idx}")\n',hints:["Convert tree to numpy array: tree_arr = np.array(tree)","Compute distances: dists = np.linalg.norm(tree_arr - target, axis=1)","Find min: idx = np.argmin(dists)","return idx, tree[idx]"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"exercise-523-simple-rrt",children:"Exercise 5.2.3: Simple RRT"}),"\n",(0,r.jsx)(n.p,{children:"Implement basic RRT for 2D point robot."}),"\n",(0,r.jsx)(i,{id:"ex-5-2-3",title:"RRT Planner",starterCode:'import numpy as np\n\ndef simple_rrt(start, goal, bounds, max_iters=500, step_size=0.5):\n  """Build RRT from start toward goal.\n\n  Args:\n      start: (x, y) start configuration\n      goal: (x, y) goal configuration\n      bounds: ((x_min, x_max), (y_min, y_max))\n      max_iters: Maximum iterations\n      step_size: Extension step size\n\n  Returns:\n      List of tree nodes [(x, y), ...]\n  """\n  tree = [start]\n\n  for _ in range(max_iters):\n      # TODO:\n      # 1. Sample random config (or goal with 10% probability)\n      # 2. Find nearest node in tree\n      # 3. Extend toward sample by step_size\n      # 4. Add to tree if within bounds\n      # 5. If close to goal, return tree\n      pass\n\n  return tree\n\n# Test\nstart = (0.0, 0.0)\ngoal = (9.0, 9.0)\nbounds = ((0, 10), (0, 10))\ntree = simple_rrt(start, goal, bounds)\nprint(f"Tree size: {len(tree)}")\nprint(f"Final node: {tree[-1]}")\n',hints:["Sample: q_rand = (np.random.uniform(bounds[0][0], bounds[0][1]), ...)","Goal bias: if np.random.rand() < 0.1: q_rand = goal","Extend: direction = (q_rand - q_near) / distance; q_new = q_near + direction * step_size","Check goal: if distance(q_new, goal) < step_size: return tree"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"6-try-with-ai",children:"6. Try With AI"}),"\n",(0,r.jsx)(n.h3,{id:"trywithai-521-rrt-vs-prm-trade-offs",children:"TryWithAI 5.2.1: RRT vs PRM Trade-offs"}),"\n",(0,r.jsx)(o,{id:"tryai-5-2-1",title:"When to Use RRT vs PRM",role:"Teacher",scenario:"You need to choose between RRT and PRM for a robot planning task",yourTask:"Describe a scenario and pick RRT or PRM, then ask AI for feedback",aiPromptTemplate:"I have a [describe robot and environment, e.g., '6-DOF arm in static warehouse']. I chose [RRT/PRM] because [your reasoning]. Is this the right choice? What are the key trade-offs I should consider? Are there scenarios where my choice would be wrong?",successCriteria:["You understand PRM is better for static, multi-query problems","You understand RRT is better for dynamic, single-query problems","You can identify when preprocessing cost is worthwhile"],reflectionQuestions:["When would PRM fail to find narrow passages?","How does obstacle density affect RRT performance?"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Takeaways"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sampling scales"}),": Avoid r^n grid explosion with random sampling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PRM"}),": Multi-query, preprocessing roadmap, best for static environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RRT"}),": Single-query, fast exploration, best for dynamic environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Collision checking"}),": Dominates runtime, needs optimization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trade-offs"}),": Optimality vs speed, single vs multi-query"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What's Next"}),": ",(0,r.jsx)(n.a,{href:"/physical-ai-book/docs/chapter-05/lesson-03-trajectory-generation",children:"Lesson 5.3: Trajectory Generation"})," smooths paths into executable trajectories."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Estimated completion time"}),": 60 minutes | ",(0,r.jsx)(n.strong,{children:"Prerequisites"}),": Lesson 5.1 | ",(0,r.jsx)(n.strong,{children:"Difficulty"}),": B2 (Upper Intermediate)"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}function p(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);